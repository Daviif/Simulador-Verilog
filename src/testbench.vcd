$date
	Fri Aug 08 21:01:17 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testbench $end
$scope module uut $end
$var wire 1 ! branch_taken $end
$var wire 1 " clock $end
$var wire 1 # reset $end
$var wire 1 $ zero $end
$var wire 32 % write_back_data [31:0] $end
$var wire 5 & rs2 [4:0] $end
$var wire 5 ' rs1 [4:0] $end
$var wire 32 ( read_data2 [31:0] $end
$var wire 32 ) read_data1 [31:0] $end
$var wire 5 * rd [4:0] $end
$var wire 32 + pc_prox [31:0] $end
$var wire 32 , pc_plus4 [31:0] $end
$var wire 32 - pc [31:0] $end
$var wire 7 . opcode [6:0] $end
$var wire 32 / instrucao [31:0] $end
$var wire 32 0 immediate [31:0] $end
$var wire 7 1 funct7 [6:0] $end
$var wire 3 2 funct3 [2:0] $end
$var wire 32 3 branch_alvo [31:0] $end
$var wire 32 4 alu_result [31:0] $end
$var wire 32 5 alu_entrada2 [31:0] $end
$var wire 4 6 alu_control [3:0] $end
$var wire 1 7 RegWrite $end
$var wire 1 8 MemtoReg $end
$var wire 1 9 MemWrite $end
$var wire 32 : MemRead_data [31:0] $end
$var wire 1 ; MemRead $end
$var wire 1 < Branch $end
$var wire 1 = ALUSrc $end
$var wire 2 > ALUOp [1:0] $end
$var integer 32 ? i [31:0] $end
$scope module InstMem $end
$var wire 32 @ instrucao [31:0] $end
$var wire 32 A endereco [31:0] $end
$upscope $end
$scope module alu $end
$var wire 32 B entrada2 [31:0] $end
$var wire 1 $ zero $end
$var wire 32 C entrada1 [31:0] $end
$var wire 4 D alu_control [3:0] $end
$var reg 32 E resultado [31:0] $end
$upscope $end
$scope module aluCtrl $end
$var wire 3 F funct3 [2:0] $end
$var wire 7 G funct7 [6:0] $end
$var wire 2 H ALUOp [1:0] $end
$var reg 4 I alu_control [3:0] $end
$upscope $end
$scope module ctrl $end
$var wire 7 J opcode [6:0] $end
$var reg 2 K ALUOp [1:0] $end
$var reg 1 = ALUSrc $end
$var reg 1 < Branch $end
$var reg 1 ; MemRead $end
$var reg 1 9 MemWrite $end
$var reg 1 8 MemtoReg $end
$var reg 1 7 RegWrite $end
$upscope $end
$scope module dataMem $end
$var wire 1 ; MemRead $end
$var wire 1 9 MemWrite $end
$var wire 1 " clock $end
$var wire 32 L endereco [31:0] $end
$var wire 32 M write_data [31:0] $end
$var wire 32 N read_data [31:0] $end
$upscope $end
$scope module immGen $end
$var wire 32 O instrucao [31:0] $end
$var wire 7 P opcode [6:0] $end
$var reg 32 Q imm_out [31:0] $end
$upscope $end
$scope module pc_mux $end
$var wire 32 R entrada1 [31:0] $end
$var wire 32 S entrada2 [31:0] $end
$var wire 1 ! seletor $end
$var wire 32 T saida [31:0] $end
$upscope $end
$scope module pc_reg $end
$var wire 1 " clock $end
$var wire 32 U pc_prox [31:0] $end
$var wire 1 # reset $end
$var reg 32 V pc [31:0] $end
$upscope $end
$scope module registradores $end
$var wire 1 7 RegWrite $end
$var wire 1 " clock $end
$var wire 5 W rd [4:0] $end
$var wire 5 X rs1 [4:0] $end
$var wire 5 Y rs2 [4:0] $end
$var wire 32 Z write_data [31:0] $end
$var reg 32 [ read_data1 [31:0] $end
$var reg 32 \ read_data2 [31:0] $end
$var integer 32 ] i [31:0] $end
$upscope $end
$scope module write_back_mux $end
$var wire 32 ^ entrada1 [31:0] $end
$var wire 32 _ entrada2 [31:0] $end
$var wire 1 8 seletor $end
$var wire 32 ` saida [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10 `
b0 _
b10 ^
b100000 ]
b0 \
b0 [
b10 Z
b10 Y
b0 X
b10 W
b0 V
b100 U
b100 T
b10 S
b100 R
b10 Q
b10011 P
b1000000000000100010011 O
b0 N
b0 M
b10 L
b0 K
b10011 J
b0 I
b0 H
b0 G
b0 F
b10 E
b0 D
b0 C
b10 B
b0 A
b1000000000000100010011 @
bx ?
b0 >
1=
0<
0;
b0 :
09
08
17
b0 6
b10 5
b10 4
b10 3
b0 2
b0 1
b10 0
b1000000000000100010011 /
b10011 .
b0 -
b100 ,
b100 +
b10 *
b0 )
b0 (
b0 '
b10 &
b10 %
0$
1#
0"
0!
$end
#5000
b10 (
b10 M
b10 \
1"
#10000
0"
0#
#15000
b11 %
b11 Z
b11 `
b11 4
b11 E
b11 L
b11 ^
b11 5
b11 B
b0 (
b0 M
b0 \
b11 0
b11 Q
b11 &
b11 Y
b100 *
b100 W
b1100000000001000010011 /
b1100000000001000010011 @
b1100000000001000010011 O
b1000 +
b1000 T
b1000 U
b111 3
b111 S
b1000 ,
b1000 R
b100 -
b100 A
b100 V
1"
#20000
0"
#25000
b1 %
b1 Z
b1 `
b1 4
b1 E
b1 L
b1 ^
b100 5
b100 B
b11 (
b11 M
b11 \
b11 )
b11 C
b11 [
b110 6
b110 D
b110 I
19
07
1=
b100 0
b100 Q
b100011 P
b100 &
b100 Y
b100 '
b100 X
b10 2
b10 F
b100011 .
b100011 J
b10000100010001000100011 /
b10000100010001000100011 @
b10000100010001000100011 O
b1100 +
b1100 T
b1100 U
b1100 3
b1100 S
b1100 ,
b1100 R
b1000 -
b1000 A
b1000 V
1"
#30000
0"
#35000
1$
b0 4
b0 E
b0 L
b0 ^
b11 %
b11 Z
b11 `
b11 :
b11 N
b11 _
b0 5
b0 B
b0 (
b0 M
b0 \
18
1;
17
1=
09
b0 0
b0 Q
b11 P
b0 &
b0 Y
b111 *
b111 W
b11 .
b11 J
b100010001110000011 /
b100010001110000011 @
b100010001110000011 O
b10000 +
b10000 T
b10000 U
b1100 3
b1100 S
b10000 ,
b10000 R
b1100 -
b1100 A
b1100 V
1"
#40000
0"
#45000
1!
b0 %
b0 Z
b0 `
b0 :
b0 N
b0 _
b11 5
b11 B
b11 (
b11 M
b11 \
b1 6
b1 D
b1 I
b1 >
b1 H
b1 K
1<
08
07
0=
0;
b1100011 0
b1100011 Q
b1100011 P
b111 &
b111 Y
b111 '
b111 X
b0 2
b0 F
b0 *
b0 W
b1100011 .
b1100011 J
b11100111000000001100011 /
b11100111000000001100011 @
b11100111000000001100011 O
b1110011 +
b1110011 T
b1110011 U
b1110011 3
b1110011 S
b10100 ,
b10100 R
b10000 -
b10000 A
b10000 V
1"
#50000
0"
#55000
bx %
bx Z
bx `
bx 5
bx B
x$
bx 4
bx E
bx L
bx ^
0!
bx (
bx M
bx \
bx )
bx C
bx [
b0 6
b0 D
b0 I
b0 >
b0 H
b0 K
0<
b0 0
b0 Q
bx P
bx 1
bx G
bx &
bx Y
bx '
bx X
bx 2
bx F
bx *
bx W
bx .
bx J
bx /
bx @
bx O
b1110111 +
b1110111 T
b1110111 U
b1110011 3
b1110011 S
b1110111 ,
b1110111 R
b1110011 -
b1110011 A
b1110011 V
1"
#60000
0"
